// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.3;

// Uncomment this line to use console.log
// import "hardhat/console.sol";
import "./SharedStructs.sol";

import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";

import "@chainlink/contracts/src/v0.8/ChainlinkClient.sol";
import "@chainlink/contracts/src/v0.8/ConfirmedOwner.sol";

import "@openzeppelin/contracts/utils/Strings.sol";

/** 
 * @title WHTVendor
 * @dev Implements Energy production and consumption logics.
 */
contract WHTVendor is ChainlinkClient, ConfirmedOwner {
    using Chainlink for Chainlink.Request;

    uint256 public volume;
    bytes32 private jobId;
    uint256 private fee;

    event RequestVolume(bytes32 indexed requestId, uint256 volume);

    // address payable public owner;
    
    SharedStructs.User[] public _users;
    mapping (address => uint) private usersIndex;
    // mapping (string => SharedStructs.Source) private sources;
    SharedStructs.Source[] public sources;

    event AddedSource(string sourceID, uint when);
    event AddedBalanceToSource(string sourceID, SharedStructs.Balance balance, uint when);
    event AddedUser(address user, uint when);
    event AddedBalanceToUser(SharedStructs.Balance balance, uint when);

    uint public immutable interval;
    uint public lastTimeStamp;
    
    uint private usersUpkeepIndex;

    constructor() ConfirmedOwner(msg.sender) {
        interval = 10; //TODO should be 24*3600
        lastTimeStamp = block.timestamp;
        usersUpkeepIndex = 0;

        setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);
        setChainlinkOracle(0x40193c8518BB267228Fc409a613bDbD8eC5a97b3);
        jobId = 'ca98366cc7314957b8c012c72f05aeeb';
        fee = (1 * LINK_DIVISIBILITY) / 10; // 0,1 * 10**18 (Varies by network and job)
    }

    function checkUpkeep(bytes calldata /* checkData */) external view returns (bool upkeepNeeded) {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
    }

    function performUpkeep(bytes calldata /* performData */) external {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval ) {
            lastTimeStamp = block.timestamp;
            
            for(uint i=0; i<sources.length; i++){
                newSourceBalance(i, 8500000000000);
            }

            for(uint i=0; i<_users.length; i++){
                requestUserConsumption();

                if (usersUpkeepIndex >= i) {
                    usersUpkeepIndex = 0;
                } else {
                    usersUpkeepIndex = i;
                }
            }
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    /** 
    * @dev Add energy source.
    * @param sourceType the type of energy source it is using (eolic, solar, gas, nuclear, ...).
    * @param sourceID the identificator of the source.
    * @param displayName the name displayed on the Spark app.
    * @param WHTPriceUSD price per Wh * 1000000.
    */
    function addSource(string memory sourceType, string memory sourceID, string memory displayName, uint WHTPriceUSD) public {
        // require (!sources[sourceID]);

        sources.push();
        uint256 newIndex = sources.length - 1;

        sources[newIndex].index = newIndex;
        sources[newIndex].sourceID = sourceID;
        sources[newIndex].sourceType = sourceType;
        sources[newIndex].displayName = displayName;
        sources[newIndex].WHTPriceUSD = WHTPriceUSD;
        sources[newIndex].currentBalance = SharedStructs.Balance({
            WHTBalance: 0,
            WHTPriceUSD: WHTPriceUSD,
            timestamp: block.timestamp
        });

        sources[newIndex].historyBalance.push();
        uint256 newHistoryIndex = sources[newIndex].historyBalance.length - 1;
        sources[newIndex].historyBalance[newHistoryIndex].WHTBalance = 0;
        sources[newIndex].historyBalance[newHistoryIndex].WHTPriceUSD = WHTPriceUSD;
        sources[newIndex].historyBalance[newHistoryIndex].timestamp = block.timestamp;

        emit AddedSource(sourceID, block.timestamp);
    }
    
    /** 
    * @dev Add new energy generated to a source.
    * @param sourceIndex source identificator in the sources array.
    * @param WHTBalance generated amount of Wh.
    */
    function newSourceBalance(uint sourceIndex, uint WHTBalance) public {
        // require (!sources[sourceID]);

        sources[sourceIndex].currentBalance.WHTBalance = WHTBalance; // all energy not consumed is lost
        sources[sourceIndex].currentBalance.timestamp = block.timestamp;

        sources[sourceIndex].historyBalance.push();
        uint256 newHistoryIndex = sources[sourceIndex].historyBalance.length - 1;

        sources[sourceIndex].historyBalance[newHistoryIndex - 1].WHTBalance = WHTBalance;

        sources[sourceIndex].historyBalance[newHistoryIndex].WHTBalance = 0;
        sources[sourceIndex].historyBalance[newHistoryIndex].WHTPriceUSD = sources[sourceIndex].currentBalance.WHTPriceUSD;
        sources[sourceIndex].historyBalance[newHistoryIndex].timestamp = block.timestamp;

        emit AddedBalanceToSource(sources[sourceIndex].sourceID, sources[sourceIndex].currentBalance, block.timestamp);
        
    }

    /** 
    * @dev Add user.
    * @param meterID the identificator of the source.
    * @param displayName the name displayed on the Spark app.
    */
    function addUser(string memory displayName, string memory meterID) public {
        // require (!sources[sourceID]);

        _users.push();
        uint256 newIndex = _users.length - 1;

        _users[newIndex].displayName= displayName;
        _users[newIndex].meterID= meterID;
        _users[newIndex].pendingUSDBalance= 0;
        _users[newIndex].pendingBalance.push();
        _users[newIndex].historyBalance.push();

        usersIndex[msg.sender] = newIndex;

        emit AddedUser(msg.sender, block.timestamp);
    }

    /** 
    * @dev Add new energy consumed and USD debt to a user.
    * @param sourceIndex source identificator in the sources array.
    * @param WHTBalance generated amount of Wh.
    */
    function newUserBalance(uint _userIndex, uint WHTBalance, uint sourceIndex) public {
        // require (!sources[sourceID]);

        // deduce Wh from source balance
        sources[sourceIndex].currentBalance.WHTBalance -= WHTBalance;

        _users[_userIndex].pendingUSDBalance += WHTBalance * sources[sourceIndex].currentBalance.WHTPriceUSD;

        _users[_userIndex].pendingBalance.push();
        uint256 newIndex = _users[_userIndex].pendingBalance.length - 1;
        _users[_userIndex].pendingBalance[newIndex].WHTBalance = WHTBalance;
        _users[_userIndex].pendingBalance[newIndex].WHTPriceUSD = sources[sourceIndex].currentBalance.WHTPriceUSD;
        _users[_userIndex].pendingBalance[newIndex].timestamp = block.timestamp;

        _users[_userIndex].historyBalance.push();
        uint256 newHistoryIndex = _users[_userIndex].historyBalance.length - 1;
        _users[_userIndex].historyBalance[newHistoryIndex].WHTBalance = WHTBalance;
        _users[_userIndex].historyBalance[newHistoryIndex].WHTPriceUSD = sources[sourceIndex].currentBalance.WHTPriceUSD;
        _users[_userIndex].historyBalance[newHistoryIndex].timestamp = block.timestamp;

        emit AddedBalanceToUser(_users[_userIndex].pendingBalance[newIndex], block.timestamp);
    }

    /** 
    * @dev Sets user source preferences.
    */
    function newUserPreferences(address user, SharedStructs.Preferences[] memory preferences) public {
        delete _users[usersIndex[user]].preferences;
        for(uint i=0; i<preferences.length; i++) {
            _users[usersIndex[user]].preferences.push();
            _users[usersIndex[user]].preferences[i].sourceIndex = preferences[i].sourceIndex;
            _users[usersIndex[user]].preferences[i].percentage = preferences[i].percentage;
        }
        // emit AddedBalanceToUser(_users[_userIndex].pendingBalance[newIndex], block.timestamp);
    }

    /** 
    * @dev returns the current balance of a source
    * @param sourceIndex source identificator in the sources array.
    */
    function getSourceBalance(uint sourceIndex) public view returns(SharedStructs.Balance memory) {
        return sources[sourceIndex].currentBalance;
    }

    /** 
    * @dev returns the history of balances of a source
    * @param sourceIndex source identificator in the sources array.
    */
    function getSourceBalanceHistory(uint sourceIndex) public view returns(SharedStructs.Balance[] memory) {
        return sources[sourceIndex].historyBalance;
    }

    /** 
    * @dev returns the user
    * @param user.
    */
    function getUserFromAddress(address user) public view returns(SharedStructs.User memory) {
        return _users[usersIndex[user]];
    }

    /** 
    * @dev returns the user source preferences
    * @param user.
    */
    function getUserPreferences(address user) public view returns(SharedStructs.Preferences[] memory) {
        return _users[usersIndex[user]].preferences;
    }

    /** 
    * @dev returns the pending balances of a user
    * @param user.
    */
    function getUserBalance(address user) public view returns(SharedStructs.Balance[] memory) {
        return _users[usersIndex[user]].pendingBalance;
    }

    /** 
    * @dev returns the history of balances of a user
    * @param user.
    */
    function getUserBalanceHistory(address user) public view returns(SharedStructs.Balance[] memory) {
        return _users[usersIndex[user]].historyBalance;
    }


    function requestUserConsumption() public returns (bytes32 requestId) {
        Chainlink.Request memory req = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);

        // Set the URL to perform the GET request on
        req.add("get", "https://apark-protocol-api.netlify.app/.netlify/functions/getuserwhconsumption");

        // Set the path to find the desired data in the API response, where the response format is:
        // {
        //    "value": x
        //  }
        req.add("path", "value"); // Chainlink nodes 1.0.0 and later support this format

        // Multiply the result by 1000000000000000000 to remove decimals
        int256 timesAmount = 1;
        req.addInt("times", timesAmount);

        // Sends the request
        return sendChainlinkRequest(req, fee);
    }

    /**
     * Receive the response in the form of uint256
     */
    function fulfill(bytes32 _requestId, uint256 _volume) public recordChainlinkFulfillment(_requestId) {
        for(uint i=0; i<_users[usersUpkeepIndex].preferences.length; i++) {
            newUserBalance(usersUpkeepIndex, _volume * _users[usersUpkeepIndex].preferences[i].percentage / 100, _users[usersUpkeepIndex].preferences[i].sourceIndex);
        }

        volume = _volume; //for debugging purposes

        emit RequestVolume(_requestId, _volume);
    }

    /**
     * Allow withdraw of Link tokens from the contract
     */
    function withdrawLink() public onlyOwner {
        LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
        require(link.transfer(msg.sender, link.balanceOf(address(this))), 'Unable to transfer');
    }
}
